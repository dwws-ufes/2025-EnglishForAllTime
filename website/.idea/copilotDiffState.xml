<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/backend/controller/SemanticController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/backend/controller/SemanticController.java" />
              <option name="originalContent" value="package com.backend.controller;&#10;&#10;import com.backend.dto.WordDetailsDTO;&#10;import com.backend.dto.NestedWordDetailsDTO;&#10;import com.backend.service.SemanticService;&#10;import com.backend.exception.WordNotFoundException;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/semantic&quot;)&#10;@Slf4j&#10;public class SemanticController {&#10;&#10;    @Autowired&#10;    private SemanticService semanticService;&#10;&#10;    @GetMapping(&quot;/definition/{word}&quot;)&#10;    public ResponseEntity&lt;?&gt; getDefinition(@PathVariable String word) {&#10;        try {&#10;            WordDetailsDTO wordDetails = semanticService.getWordDetails(word);&#10;&#10;            // Extrair apenas as definições para compatibilidade&#10;            StringBuilder definitions = new StringBuilder();&#10;            if (wordDetails.meanings() != null) {&#10;                wordDetails.meanings().forEach(meaning -&gt; {&#10;                    if (meaning.definitions() != null) {&#10;                        meaning.definitions().forEach(def -&gt; {&#10;                            if (definitions.length() &gt; 0) definitions.append(&quot;; &quot;);&#10;                            definitions.append(def.definition());&#10;                        });&#10;                    }&#10;                });&#10;            }&#10;&#10;            return ResponseEntity.ok(new DefinitionResponse(word, definitions.toString()));&#10;&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Definição não encontrada para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar definição para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/translation/{word}&quot;)&#10;    public ResponseEntity&lt;?&gt; getTranslation(@PathVariable String word) {&#10;        try {&#10;            WordDetailsDTO wordDetails = semanticService.getWordDetails(word);&#10;&#10;            if (wordDetails.translation() != null &amp;&amp; !wordDetails.translation().isEmpty()) {&#10;                return ResponseEntity.ok(new TranslationResponse(word, wordDetails.translation()));&#10;            } else {&#10;                return ResponseEntity.notFound().build();&#10;            }&#10;&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Tradução não encontrada para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar tradução para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    // Endpoint unificado que retorna todos os detalhes da palavra&#10;    @GetMapping(&quot;/word/{word}&quot;)&#10;    public ResponseEntity&lt;WordDetailsDTO&gt; getWordDetails(@PathVariable String word) {&#10;        try {&#10;            WordDetailsDTO wordDetails = semanticService.getWordDetails(word);&#10;            return ResponseEntity.ok(wordDetails);&#10;&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Palavra não encontrada: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar palavra '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    // Endpoint com aninhamento: busca a palavra e os detalhes do primeiro sinônimo&#10;    @GetMapping(&quot;/word/{word}/nested&quot;)&#10;    public ResponseEntity&lt;NestedWordDetailsDTO&gt; getWordDetailsWithNesting(@PathVariable String word) {&#10;        try {&#10;            NestedWordDetailsDTO nestedWordDetails = semanticService.getWordDetailsWithNesting(word);&#10;            return ResponseEntity.ok(nestedWordDetails);&#10;&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Palavra não encontrada para aninhamento: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar palavra com aninhamento '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    public record DefinitionResponse(String word, String definition) {}&#10;    public record TranslationResponse(String word, String translation) {}&#10;}" />
              <option name="updatedContent" value="package com.backend.controller;&#10;&#10;import com.backend.dto.WordDetailsDTO;&#10;import com.backend.dto.NestedWordDetailsDTO;&#10;import com.backend.service.SemanticService;&#10;import com.backend.exception.WordNotFoundException;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/semantic&quot;)&#10;@Slf4j&#10;public class SemanticController {&#10;&#10;    @Autowired&#10;    private SemanticService semanticService;&#10;&#10;    @GetMapping(&quot;/definition/{word}&quot;)&#10;    public ResponseEntity&lt;?&gt; getDefinition(@PathVariable String word) {&#10;        try {&#10;            WordDetailsDTO wordDetails = semanticService.getWordDetails(word);&#10;&#10;            // Extrair apenas as definições para compatibilidade&#10;            StringBuilder definitions = new StringBuilder();&#10;            if (wordDetails.meanings() != null) {&#10;                wordDetails.meanings().forEach(meaning -&gt; {&#10;                    if (meaning.definitions() != null) {&#10;                        meaning.definitions().forEach(def -&gt; {&#10;                            if (definitions.length() &gt; 0) definitions.append(&quot;; &quot;);&#10;                            definitions.append(def.definition());&#10;                        });&#10;                    }&#10;                });&#10;            }&#10;&#10;            return ResponseEntity.ok(new DefinitionResponse(word, definitions.toString()));&#10;&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Definição não encontrada para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar definição para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/translation/{word}&quot;)&#10;    public ResponseEntity&lt;?&gt; getTranslation(@PathVariable String word) {&#10;        try {&#10;            String translation = semanticService.getTranslation(word);&#10;            return ResponseEntity.ok(new TranslationResponse(word, translation));&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Tradução não encontrada para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar tradução para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/word-details/{word}&quot;)&#10;    public ResponseEntity&lt;WordDetailsDTO&gt; getWordDetails(@PathVariable String word) {&#10;        try {&#10;            WordDetailsDTO wordDetails = semanticService.getWordDetails(word);&#10;            return ResponseEntity.ok(wordDetails);&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Detalhes não encontrados para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar detalhes para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/nested-details/{word}&quot;)&#10;    public ResponseEntity&lt;NestedWordDetailsDTO&gt; getNestedWordDetails(@PathVariable String word) {&#10;        try {&#10;            NestedWordDetailsDTO nestedDetails = semanticService.getNestedWordDetails(word);&#10;            return ResponseEntity.ok(nestedDetails);&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Detalhes aninhados não encontrados para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar detalhes aninhados para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    // NOVA FUNCIONALIDADE: Rede Semântica de Palavras&#10;    @GetMapping(&quot;/semantic-network/{word}&quot;)&#10;    public ResponseEntity&lt;SemanticNetworkDTO&gt; getSemanticNetwork(@PathVariable String word) {&#10;        try {&#10;            SemanticNetworkDTO semanticNetwork = semanticService.getSemanticNetwork(word);&#10;            return ResponseEntity.ok(semanticNetwork);&#10;        } catch (WordNotFoundException e) {&#10;            log.warn(&quot;Rede semântica não encontrada para palavra: {}&quot;, word);&#10;            return ResponseEntity.notFound().build();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Erro ao buscar rede semântica para '{}': {}&quot;, word, e.getMessage());&#10;            return ResponseEntity.internalServerError().build();&#10;        }&#10;    }&#10;&#10;    // Classes internas para respostas&#10;    public static record DefinitionResponse(String word, String definition) {}&#10;    public static record TranslationResponse(String word, String translation) {}&#10;&#10;    // DTO para Rede Semântica&#10;    public static record SemanticNetworkDTO(&#10;        String word,&#10;        String etymology,&#10;        String wordFamily,&#10;        java.util.List&lt;RelatedWord&gt; synonyms,&#10;        java.util.List&lt;RelatedWord&gt; antonyms,&#10;        java.util.List&lt;RelatedWord&gt; relatedWords,&#10;        java.util.List&lt;String&gt; cognates,&#10;        WordOrigin origin,&#10;        java.util.List&lt;LanguageConnection&gt; connections&#10;    ) {}&#10;&#10;    public static record RelatedWord(String word, String relation, Double similarity) {}&#10;    public static record WordOrigin(String language, String originalForm, String meaning) {}&#10;    public static record LanguageConnection(String language, String form, String meaning) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/backend/service/SemanticService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/backend/service/SemanticService.java" />
              <option name="originalContent" value="package com.backend.service;&#10;&#10;import com.backend.dto.WordDetailsDTO;&#10;import com.backend.dto.MeaningDTO;&#10;import com.backend.dto.DefinitionDTO;&#10;import com.backend.dto.NestedWordDetailsDTO;&#10;import com.backend.exception.WordNotFoundException;&#10;import com.fasterxml.jackson.core.JsonProcessingException;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.HttpClientErrorException;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Service&#10;@Slf4j&#10;public class SemanticService {&#10;&#10;    private final RestTemplate restTemplate;&#10;    private final ObjectMapper objectMapper;&#10;&#10;    @Value(&quot;${dictionary.api.url:https://api.dictionaryapi.dev/api/v2/entries/en}&quot;)&#10;    private String dictionaryApiUrl;&#10;&#10;    @Value(&quot;${translation.api.url:https://api.mymemory.translated.net/get}&quot;)&#10;    private String translationApiUrl;&#10;&#10;    public SemanticService(RestTemplate restTemplate, ObjectMapper objectMapper) {&#10;        this.restTemplate = restTemplate;&#10;        this.objectMapper = objectMapper;&#10;    }&#10;&#10;    public WordDetailsDTO getWordDetails(String word) {&#10;        log.info(&quot; Buscando detalhes para palavra: {}&quot;, word);&#10;&#10;        try {&#10;            // 1. Buscar definições na API do dicionário&#10;            WordDetailsDTO wordDetails = fetchWordDefinitions(word);&#10;&#10;            // 2. Buscar tradução (opcional, não falha se der erro)&#10;            try {&#10;                String translation = fetchTranslation(word);&#10;                // Como record é imutável, criamos uma nova instância com tradução&#10;                wordDetails = new WordDetailsDTO(&#10;                        wordDetails.word(),&#10;                        wordDetails.phonetic(),&#10;                        wordDetails.meanings(),&#10;                        translation&#10;                );&#10;            } catch (Exception e) {&#10;                log.warn(&quot;⚠️ Não foi possível obter tradução para '{}': {}&quot;, word, e.getMessage());&#10;                // Continua sem tradução&#10;            }&#10;&#10;            log.info(&quot;✅ Detalhes encontrados para palavra: {}&quot;, word);&#10;            return wordDetails;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao buscar palavra '{}': {}&quot;, word, e.getMessage());&#10;            throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;        }&#10;    }&#10;&#10;    public NestedWordDetailsDTO getWordDetailsWithNesting(String word) {&#10;        log.info(&quot; Buscando detalhes com aninhamento para palavra: {}&quot;, word);&#10;&#10;        try {&#10;            // 1. Buscar detalhes da palavra principal&#10;            WordDetailsDTO mainWordDetails = getWordDetails(word);&#10;&#10;            // 2. Encontrar o primeiro sinônimo da primeira definição&#10;            String firstSynonym = findFirstSynonym(mainWordDetails);&#10;&#10;            WordDetailsDTO nestedSynonymDetails = null;&#10;            if (firstSynonym != null &amp;&amp; !firstSynonym.isEmpty()) {&#10;                log.info(&quot; Buscando detalhes do primeiro sinônimo: {}&quot;, firstSynonym);&#10;                try {&#10;                    nestedSynonymDetails = getWordDetails(firstSynonym);&#10;                    log.info(&quot;✅ Detalhes do sinônimo '{}' encontrados&quot;, firstSynonym);&#10;                } catch (Exception e) {&#10;                    log.warn(&quot;⚠️ Não foi possível obter detalhes do sinônimo '{}': {}&quot;, firstSynonym, e.getMessage());&#10;                }&#10;            } else {&#10;                log.info(&quot;ℹ️ Nenhum sinônimo encontrado para aninhamento&quot;);&#10;            }&#10;&#10;            return new NestedWordDetailsDTO(mainWordDetails, nestedSynonymDetails);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao buscar palavra com aninhamento '{}': {}&quot;, word, e.getMessage());&#10;            throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;        }&#10;    }&#10;&#10;    private String findFirstSynonym(WordDetailsDTO wordDetails) {&#10;        if (wordDetails.meanings() != null &amp;&amp; !wordDetails.meanings().isEmpty()) {&#10;            // Pegar a primeira meaning (primeiro significado)&#10;            MeaningDTO firstMeaning = wordDetails.meanings().get(0);&#10;&#10;            if (firstMeaning.synonyms() != null &amp;&amp; !firstMeaning.synonyms().isEmpty()) {&#10;                // Retornar o primeiro sinônimo&#10;                return firstMeaning.synonyms().get(0);&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private WordDetailsDTO fetchWordDefinitions(String word) {&#10;        String url = dictionaryApiUrl + &quot;/&quot; + word.toLowerCase().trim();&#10;&#10;        log.debug(&quot; Consultando API: {}&quot;, url);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);&#10;&#10;            if (response.getStatusCode().is2xxSuccessful() &amp;&amp; response.getBody() != null) {&#10;                JsonNode jsonArray = objectMapper.readTree(response.getBody());&#10;&#10;                if (jsonArray.isArray() &amp;&amp; jsonArray.size() &gt; 0) {&#10;                    JsonNode firstResult = jsonArray.get(0);&#10;                    return parseWordDetails(firstResult, word);&#10;                }&#10;            }&#10;&#10;            throw new WordNotFoundException(&quot;Nenhum resultado encontrado para: &quot; + word);&#10;&#10;        } catch (JsonProcessingException e) {&#10;            log.error(&quot;❌ Erro ao processar JSON da API do dicionário: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Erro ao processar resposta da API: &quot; + e.getMessage());&#10;        } catch (HttpClientErrorException e) {&#10;            if (e.getStatusCode() == HttpStatus.NOT_FOUND) {&#10;                log.warn(&quot; Palavra '{}' não encontrada na API do dicionário&quot;, word);&#10;                throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;            }&#10;            throw new RuntimeException(&quot;Erro na consulta à API do dicionário: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private WordDetailsDTO parseWordDetails(JsonNode wordJson, String originalWord) {&#10;        // Word&#10;        String word = wordJson.path(&quot;word&quot;).asText(originalWord);&#10;&#10;        // Phonetic&#10;        String phonetic = null;&#10;        JsonNode phoneticsArray = wordJson.path(&quot;phonetics&quot;);&#10;        if (phoneticsArray.isArray() &amp;&amp; phoneticsArray.size() &gt; 0) {&#10;            for (JsonNode phoneticNode : phoneticsArray) {&#10;                String phoneticText = phoneticNode.path(&quot;text&quot;).asText();&#10;                if (!phoneticText.isEmpty()) {&#10;                    phonetic = phoneticText;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Meanings&#10;        List&lt;MeaningDTO&gt; meanings = new ArrayList&lt;&gt;();&#10;        JsonNode meaningsArray = wordJson.path(&quot;meanings&quot;);&#10;        if (meaningsArray.isArray()) {&#10;            for (JsonNode meaningJson : meaningsArray) {&#10;                String partOfSpeech = meaningJson.path(&quot;partOfSpeech&quot;).asText();&#10;&#10;                // Definitions&#10;                List&lt;DefinitionDTO&gt; definitions = new ArrayList&lt;&gt;();&#10;                JsonNode definitionsArray = meaningJson.path(&quot;definitions&quot;);&#10;                if (definitionsArray.isArray()) {&#10;                    for (JsonNode defJson : definitionsArray) {&#10;                        String definition = defJson.path(&quot;definition&quot;).asText();&#10;                        String example = defJson.path(&quot;example&quot;).asText(null);&#10;                        definitions.add(new DefinitionDTO(definition, example));&#10;                    }&#10;                }&#10;&#10;                // Synonyms&#10;                List&lt;String&gt; synonyms = new ArrayList&lt;&gt;();&#10;                JsonNode synonymsArray = meaningJson.path(&quot;synonyms&quot;);&#10;                if (synonymsArray.isArray()) {&#10;                    for (JsonNode synonym : synonymsArray) {&#10;                        synonyms.add(synonym.asText());&#10;                    }&#10;                }&#10;&#10;                meanings.add(new MeaningDTO(partOfSpeech, definitions, synonyms));&#10;            }&#10;        }&#10;&#10;        return new WordDetailsDTO(word, phonetic, meanings, null);&#10;    }&#10;&#10;    private String fetchTranslation(String word) {&#10;        String url = translationApiUrl + &quot;?q=&quot; + word + &quot;&amp;langpair=en|pt&quot;;&#10;&#10;        log.debug(&quot; Buscando tradução: {}&quot;, url);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);&#10;&#10;            if (response.getStatusCode().is2xxSuccessful() &amp;&amp; response.getBody() != null) {&#10;                JsonNode jsonResponse = objectMapper.readTree(response.getBody());&#10;                return jsonResponse.path(&quot;responseData&quot;).path(&quot;translatedText&quot;).asText();&#10;            }&#10;&#10;        } catch (JsonProcessingException e) {&#10;            log.warn(&quot;⚠️ Erro ao processar JSON da tradução: {}&quot;, e.getMessage());&#10;        } catch (Exception e) {&#10;            log.warn(&quot;⚠️ Erro na tradução: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return null;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.backend.service;&#10;&#10;import com.backend.dto.WordDetailsDTO;&#10;import com.backend.dto.MeaningDTO;&#10;import com.backend.dto.DefinitionDTO;&#10;import com.backend.dto.NestedWordDetailsDTO;&#10;import com.backend.exception.WordNotFoundException;&#10;import com.fasterxml.jackson.core.JsonProcessingException;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.HttpClientErrorException;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Service&#10;@Slf4j&#10;public class SemanticService {&#10;&#10;    private final RestTemplate restTemplate;&#10;    private final ObjectMapper objectMapper;&#10;&#10;    @Value(&quot;${dictionary.api.url:https://api.dictionaryapi.dev/api/v2/entries/en}&quot;)&#10;    private String dictionaryApiUrl;&#10;&#10;    @Value(&quot;${translation.api.url:https://api.mymemory.translated.net/get}&quot;)&#10;    private String translationApiUrl;&#10;&#10;    public SemanticService(RestTemplate restTemplate, ObjectMapper objectMapper) {&#10;        this.restTemplate = restTemplate;&#10;        this.objectMapper = objectMapper;&#10;    }&#10;&#10;    public WordDetailsDTO getWordDetails(String word) {&#10;        log.info(&quot; Buscando detalhes para palavra: {}&quot;, word);&#10;&#10;        try {&#10;            // 1. Buscar definições na API do dicionário&#10;            WordDetailsDTO wordDetails = fetchWordDefinitions(word);&#10;&#10;            // 2. Buscar tradução (opcional, não falha se der erro)&#10;            try {&#10;                String translation = fetchTranslation(word);&#10;                // Como record é imutável, criamos uma nova instância com tradução&#10;                wordDetails = new WordDetailsDTO(&#10;                        wordDetails.word(),&#10;                        wordDetails.phonetic(),&#10;                        wordDetails.meanings(),&#10;                        translation&#10;                );&#10;            } catch (Exception e) {&#10;                log.warn(&quot;⚠️ Não foi possível obter tradução para '{}': {}&quot;, word, e.getMessage());&#10;                // Continua sem tradução&#10;            }&#10;&#10;            log.info(&quot;✅ Detalhes encontrados para palavra: {}&quot;, word);&#10;            return wordDetails;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao buscar palavra '{}': {}&quot;, word, e.getMessage());&#10;            throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;        }&#10;    }&#10;&#10;    public NestedWordDetailsDTO getWordDetailsWithNesting(String word) {&#10;        log.info(&quot; Buscando detalhes com aninhamento para palavra: {}&quot;, word);&#10;&#10;        try {&#10;            // 1. Buscar detalhes da palavra principal&#10;            WordDetailsDTO mainWordDetails = getWordDetails(word);&#10;&#10;            // 2. Encontrar o primeiro sinônimo da primeira definição&#10;            String firstSynonym = findFirstSynonym(mainWordDetails);&#10;&#10;            WordDetailsDTO nestedSynonymDetails = null;&#10;            if (firstSynonym != null &amp;&amp; !firstSynonym.isEmpty()) {&#10;                log.info(&quot; Buscando detalhes do primeiro sinônimo: {}&quot;, firstSynonym);&#10;                try {&#10;                    nestedSynonymDetails = getWordDetails(firstSynonym);&#10;                    log.info(&quot;✅ Detalhes do sinônimo '{}' encontrados&quot;, firstSynonym);&#10;                } catch (Exception e) {&#10;                    log.warn(&quot;⚠️ Não foi possível obter detalhes do sinônimo '{}': {}&quot;, firstSynonym, e.getMessage());&#10;                }&#10;            } else {&#10;                log.info(&quot;ℹ️ Nenhum sinônimo encontrado para aninhamento&quot;);&#10;            }&#10;&#10;            return new NestedWordDetailsDTO(mainWordDetails, nestedSynonymDetails);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao buscar palavra com aninhamento '{}': {}&quot;, word, e.getMessage());&#10;            throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;        }&#10;    }&#10;&#10;    private String findFirstSynonym(WordDetailsDTO wordDetails) {&#10;        if (wordDetails.meanings() != null &amp;&amp; !wordDetails.meanings().isEmpty()) {&#10;            // Pegar a primeira meaning (primeiro significado)&#10;            MeaningDTO firstMeaning = wordDetails.meanings().get(0);&#10;&#10;            if (firstMeaning.synonyms() != null &amp;&amp; !firstMeaning.synonyms().isEmpty()) {&#10;                // Retornar o primeiro sinônimo&#10;                return firstMeaning.synonyms().get(0);&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private WordDetailsDTO fetchWordDefinitions(String word) {&#10;        String url = dictionaryApiUrl + &quot;/&quot; + word.toLowerCase().trim();&#10;&#10;        log.debug(&quot; Consultando API: {}&quot;, url);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);&#10;&#10;            if (response.getStatusCode().is2xxSuccessful() &amp;&amp; response.getBody() != null) {&#10;                JsonNode jsonArray = objectMapper.readTree(response.getBody());&#10;&#10;                if (jsonArray.isArray() &amp;&amp; jsonArray.size() &gt; 0) {&#10;                    JsonNode firstResult = jsonArray.get(0);&#10;                    return parseWordDetails(firstResult, word);&#10;                }&#10;            }&#10;&#10;            throw new WordNotFoundException(&quot;Nenhum resultado encontrado para: &quot; + word);&#10;&#10;        } catch (JsonProcessingException e) {&#10;            log.error(&quot;❌ Erro ao processar JSON da API do dicionário: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Erro ao processar resposta da API: &quot; + e.getMessage());&#10;        } catch (HttpClientErrorException e) {&#10;            if (e.getStatusCode() == HttpStatus.NOT_FOUND) {&#10;                log.warn(&quot; Palavra '{}' não encontrada na API do dicionário&quot;, word);&#10;                throw new WordNotFoundException(&quot;Palavra '&quot; + word + &quot;' não encontrada no dicionário&quot;);&#10;            }&#10;            throw new RuntimeException(&quot;Erro na consulta à API do dicionário: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private WordDetailsDTO parseWordDetails(JsonNode wordJson, String originalWord) {&#10;        // Word&#10;        String word = wordJson.path(&quot;word&quot;).asText(originalWord);&#10;&#10;        // Phonetic&#10;        String phonetic = null;&#10;        JsonNode phoneticsArray = wordJson.path(&quot;phonetics&quot;);&#10;        if (phoneticsArray.isArray() &amp;&amp; phoneticsArray.size() &gt; 0) {&#10;            for (JsonNode phoneticNode : phoneticsArray) {&#10;                String phoneticText = phoneticNode.path(&quot;text&quot;).asText();&#10;                if (!phoneticText.isEmpty()) {&#10;                    phonetic = phoneticText;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Meanings&#10;        List&lt;MeaningDTO&gt; meanings = new ArrayList&lt;&gt;();&#10;        JsonNode meaningsArray = wordJson.path(&quot;meanings&quot;);&#10;        if (meaningsArray.isArray()) {&#10;            for (JsonNode meaningJson : meaningsArray) {&#10;                String partOfSpeech = meaningJson.path(&quot;partOfSpeech&quot;).asText();&#10;&#10;                // Definitions&#10;                List&lt;DefinitionDTO&gt; definitions = new ArrayList&lt;&gt;();&#10;                JsonNode definitionsArray = meaningJson.path(&quot;definitions&quot;);&#10;                if (definitionsArray.isArray()) {&#10;                    for (JsonNode defJson : definitionsArray) {&#10;                        String definition = defJson.path(&quot;definition&quot;).asText();&#10;                        String example = defJson.path(&quot;example&quot;).asText(null);&#10;                        definitions.add(new DefinitionDTO(definition, example));&#10;                    }&#10;                }&#10;&#10;                // Synonyms&#10;                List&lt;String&gt; synonyms = new ArrayList&lt;&gt;();&#10;                JsonNode synonymsArray = meaningJson.path(&quot;synonyms&quot;);&#10;                if (synonymsArray.isArray()) {&#10;                    for (JsonNode synonym : synonymsArray) {&#10;                        synonyms.add(synonym.asText());&#10;                    }&#10;                }&#10;&#10;                meanings.add(new MeaningDTO(partOfSpeech, definitions, synonyms));&#10;            }&#10;        }&#10;&#10;        return new WordDetailsDTO(word, phonetic, meanings, null);&#10;    }&#10;&#10;    private String fetchTranslation(String word) {&#10;        String url = translationApiUrl + &quot;?q=&quot; + word + &quot;&amp;langpair=en|pt&quot;;&#10;&#10;        log.debug(&quot; Buscando tradução: {}&quot;, url);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);&#10;&#10;            if (response.getStatusCode().is2xxSuccessful() &amp;&amp; response.getBody() != null) {&#10;                JsonNode jsonResponse = objectMapper.readTree(response.getBody());&#10;                JsonNode responseData = jsonResponse.path(&quot;responseData&quot;);&#10;                String translatedText = responseData.path(&quot;translatedText&quot;).asText();&#10;&#10;                if (!translatedText.isEmpty()) {&#10;                    log.debug(&quot;✅ Tradução encontrada: {}&quot;, translatedText);&#10;                    return translatedText;&#10;                }&#10;            }&#10;&#10;            log.warn(&quot;⚠️ Nenhuma tradução encontrada para: {}&quot;, word);&#10;            return null;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao buscar tradução para '{}': {}&quot;, word, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    public String getTranslation(String word) {&#10;        return fetchTranslation(word);&#10;    }&#10;&#10;    public NestedWordDetailsDTO getNestedWordDetails(String word) {&#10;        return getWordDetailsWithNesting(word);&#10;    }&#10;&#10;    // NOVA FUNCIONALIDADE: Rede Semântica de Palavras&#10;    public com.backend.controller.SemanticController.SemanticNetworkDTO getSemanticNetwork(String word) {&#10;        log.info(&quot;️ Construindo rede semântica para palavra: {}&quot;, word);&#10;&#10;        try {&#10;            // 1. Buscar detalhes básicos da palavra&#10;            WordDetailsDTO wordDetails = getWordDetails(word);&#10;&#10;            // 2. Construir dados da rede semântica&#10;            return buildSemanticNetwork(word, wordDetails);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;❌ Erro ao construir rede semântica para '{}': {}&quot;, word, e.getMessage());&#10;            throw new WordNotFoundException(&quot;Não foi possível construir rede semântica para: &quot; + word);&#10;        }&#10;    }&#10;&#10;    private com.backend.controller.SemanticController.SemanticNetworkDTO buildSemanticNetwork(String word, WordDetailsDTO wordDetails) {&#10;        // Etimologia simulada (em uma implementação real, isso viria de APIs especializadas)&#10;        String etymology = generateEtymology(word);&#10;        String wordFamily = generateWordFamily(word);&#10;&#10;        // Coletar sinônimos de todos os significados&#10;        List&lt;com.backend.controller.SemanticController.RelatedWord&gt; synonyms = new ArrayList&lt;&gt;();&#10;        List&lt;com.backend.controller.SemanticController.RelatedWord&gt; relatedWords = new ArrayList&lt;&gt;();&#10;&#10;        if (wordDetails.meanings() != null) {&#10;            for (MeaningDTO meaning : wordDetails.meanings()) {&#10;                if (meaning.synonyms() != null) {&#10;                    for (String synonym : meaning.synonyms()) {&#10;                        synonyms.add(new com.backend.controller.SemanticController.RelatedWord(&#10;                            synonym, &quot;synonym&quot;, 0.9&#10;                        ));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Gerar antônimos baseados em padrões comuns&#10;        List&lt;com.backend.controller.SemanticController.RelatedWord&gt; antonyms = generateAntonyms(word);&#10;&#10;        // Gerar cognatos (palavras relacionadas em outras línguas)&#10;        List&lt;String&gt; cognates = generateCognates(word);&#10;&#10;        // Origem da palavra&#10;        com.backend.controller.SemanticController.WordOrigin origin = generateWordOrigin(word);&#10;&#10;        // Conexões linguísticas&#10;        List&lt;com.backend.controller.SemanticController.LanguageConnection&gt; connections = generateLanguageConnections(word);&#10;&#10;        // Adicionar palavras relacionadas semanticamente&#10;        relatedWords.addAll(generateSemanticRelations(word));&#10;&#10;        return new com.backend.controller.SemanticController.SemanticNetworkDTO(&#10;            word,&#10;            etymology,&#10;            wordFamily,&#10;            synonyms,&#10;            antonyms,&#10;            relatedWords,&#10;            cognates,&#10;            origin,&#10;            connections&#10;        );&#10;    }&#10;&#10;    private String generateEtymology(String word) {&#10;        // Simulação de etimologia baseada em padrões comuns&#10;        // Em uma implementação real, isso consultaria bases de dados etimológicas&#10;        switch (word.toLowerCase()) {&#10;            case &quot;happy&quot;:&#10;                return &quot;Do inglês médio 'hap' (sorte, fortuna) + sufixo '-y'. Relacionado ao nórdico antigo 'happ' (sorte).&quot;;&#10;            case &quot;computer&quot;:&#10;                return &quot;Do latim 'computare' (calcular, contar). Primeiro usado em inglês no século XVII para 'pessoa que calcula'.&quot;;&#10;            case &quot;telephone&quot;:&#10;                return &quot;Do grego 'tele' (distante) + 'phone' (som, voz). Criado por Alexander Graham Bell em 1876.&quot;;&#10;            case &quot;democracy&quot;:&#10;                return &quot;Do grego 'demokratia': 'demos' (povo) + 'kratos' (poder, governo).&quot;;&#10;            default:&#10;                return String.format(&quot;A palavra '%s' tem origens complexas e evoluiu através de várias transformações linguísticas.&quot;, word);&#10;        }&#10;    }&#10;&#10;    private String generateWordFamily(String word) {&#10;        // Família de palavras baseada em morfologia&#10;        switch (word.toLowerCase()) {&#10;            case &quot;happy&quot;:&#10;                return &quot;happiness, happily, unhappy, unhappiness&quot;;&#10;            case &quot;computer&quot;:&#10;                return &quot;compute, computation, computational, computing&quot;;&#10;            case &quot;telephone&quot;:&#10;                return &quot;telephonic, telephony, telephonist&quot;;&#10;            case &quot;democracy&quot;:&#10;                return &quot;democratic, democratize, democratization&quot;;&#10;            default:&#10;                return &quot;Família de palavras relacionadas morfologicamente&quot;;&#10;        }&#10;    }&#10;&#10;    private List&lt;com.backend.controller.SemanticController.RelatedWord&gt; generateAntonyms(String word) {&#10;        List&lt;com.backend.controller.SemanticController.RelatedWord&gt; antonyms = new ArrayList&lt;&gt;();&#10;        &#10;        // Antônimos baseados em padrões comuns&#10;        switch (word.toLowerCase()) {&#10;            case &quot;happy&quot;:&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;sad&quot;, &quot;antonym&quot;, 0.95));&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;unhappy&quot;, &quot;antonym&quot;, 0.90));&#10;                break;&#10;            case &quot;big&quot;:&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;small&quot;, &quot;antonym&quot;, 0.95));&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;little&quot;, &quot;antonym&quot;, 0.90));&#10;                break;&#10;            case &quot;hot&quot;:&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;cold&quot;, &quot;antonym&quot;, 0.95));&#10;                antonyms.add(new com.backend.controller.SemanticController.RelatedWord(&quot;cool&quot;, &quot;antonym&quot;, 0.85));&#10;                break;&#10;        }&#10;        &#10;        return antonyms;&#10;    }&#10;&#10;    private List&lt;String&gt; generateCognates(String word) {&#10;        List&lt;String&gt; cognates = new ArrayList&lt;&gt;();&#10;        &#10;        // Cognatos em diferentes línguas&#10;        switch (word.toLowerCase()) {&#10;            case &quot;computer&quot;:&#10;                cognates.add(&quot;computador (Portuguese)&quot;);&#10;                cognates.add(&quot;ordinateur (French)&quot;);&#10;                cognates.add(&quot;computadora (Spanish)&quot;);&#10;                break;&#10;            case &quot;telephone&quot;:&#10;                cognates.add(&quot;teléfono (Spanish)&quot;);&#10;                cognates.add(&quot;téléphone (French)&quot;);&#10;                cognates.add(&quot;telefone (Portuguese)&quot;);&#10;                break;&#10;            case &quot;democracy&quot;:&#10;                cognates.add(&quot;democracia (Spanish/Portuguese)&quot;);&#10;                cognates.add(&quot;démocratie (French)&quot;);&#10;                cognates.add(&quot;demokratie (German)&quot;);&#10;                break;&#10;        }&#10;        &#10;        return cognates;&#10;    }&#10;&#10;    private com.backend.controller.SemanticController.WordOrigin generateWordOrigin(String word) {&#10;        // Origem linguística da palavra&#10;        switch (word.toLowerCase()) {&#10;            case &quot;happy&quot;:&#10;                return new com.backend.controller.SemanticController.WordOrigin(&quot;Old Norse&quot;, &quot;happ&quot;, &quot;luck, fortune&quot;);&#10;            case &quot;computer&quot;:&#10;                return new com.backend.controller.SemanticController.WordOrigin(&quot;Latin&quot;, &quot;computare&quot;, &quot;to calculate&quot;);&#10;            case &quot;telephone&quot;:&#10;                return new com.backend.controller.SemanticController.WordOrigin(&quot;Greek&quot;, &quot;tele + phone&quot;, &quot;distant voice&quot;);&#10;            default:&#10;                return new com.backend.controller.SemanticController.WordOrigin(&quot;Unknown&quot;, word, &quot;Origin uncertain&quot;);&#10;        }&#10;    }&#10;&#10;    private List&lt;com.backend.controller.SemanticController.LanguageConnection&gt; generateLanguageConnections(String word) {&#10;        List&lt;com.backend.controller.SemanticController.LanguageConnection&gt; connections = new ArrayList&lt;&gt;();&#10;        &#10;        // Conexões com outras línguas&#10;        switch (word.toLowerCase()) {&#10;            case &quot;computer&quot;:&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;Portuguese&quot;, &quot;computador&quot;, &quot;máquina de calcular&quot;));&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;French&quot;, &quot;ordinateur&quot;, &quot;machine à calculer&quot;));&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;German&quot;, &quot;computer&quot;, &quot;rechner&quot;));&#10;                break;&#10;            case &quot;happy&quot;:&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;Portuguese&quot;, &quot;feliz&quot;, &quot;alegre&quot;));&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;Spanish&quot;, &quot;feliz&quot;, &quot;alegre&quot;));&#10;                connections.add(new com.backend.controller.SemanticController.LanguageConnection(&quot;French&quot;, &quot;heureux&quot;, &quot;content&quot;));&#10;                break;&#10;        }&#10;        &#10;        return connections;&#10;    }&#10;&#10;    private List&lt;com.backend.controller.SemanticController.RelatedWord&gt; generateSemanticRelations(String word) {&#10;        List&lt;com.backend.controller.SemanticController.RelatedWord&gt; relations = new ArrayList&lt;&gt;();&#10;        &#10;        // Relações semânticas baseadas em domínios&#10;        switch (word.toLowerCase()) {&#10;            case &quot;computer&quot;:&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;technology&quot;, &quot;domain&quot;, 0.85));&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;software&quot;, &quot;related&quot;, 0.80));&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;digital&quot;, &quot;related&quot;, 0.75));&#10;                break;&#10;            case &quot;happy&quot;:&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;emotion&quot;, &quot;domain&quot;, 0.90));&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;joy&quot;, &quot;related&quot;, 0.85));&#10;                relations.add(new com.backend.controller.SemanticController.RelatedWord(&quot;positive&quot;, &quot;related&quot;, 0.80));&#10;                break;&#10;        }&#10;        &#10;        return relations;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/api.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/api.js" />
              <option name="originalContent" value="import axios from 'axios';&#10;import { DEBUG } from '../util/debug';&#10;&#10;const api = axios.create({&#10;  baseURL: 'http://localhost:8080/api',&#10;  headers: {&#10;    'Content-Type': 'application/json',&#10;  }&#10;});&#10;&#10;api.interceptors.request.use((config) =&gt; {&#10;  if (DEBUG) {&#10;    console.log(' [API] Requisição saindo:', {&#10;      method: config.method?.toUpperCase(),&#10;      url: config.url,&#10;      baseURL: config.baseURL,&#10;      fullURL: `${config.baseURL}${config.url}`&#10;    });&#10;  }&#10;&#10;  // Rotas que NÃO precisam de autenticação (públicas)&#10;  const isPublicRoute = config.url?.includes('/auth/login') ||&#10;      config.url?.includes('/auth/register') ||&#10;      config.url?.includes('/dictionary/');  // Todas as rotas do dicionário são públicas&#10;&#10;  if (!isPublicRoute) {&#10;    const token = localStorage.getItem('@EnglishForAllTime:token');&#10;    if (token) {&#10;      config.headers.Authorization = `Bearer ${token}`;&#10;      if (DEBUG) console.log(' [API] Token adicionado à requisição');&#10;    } else {&#10;      if (DEBUG) console.log('⚠️ [API] Nenhum token encontrado no localStorage');&#10;    }&#10;  } else {&#10;    if (DEBUG) console.log(' [API] Rota pública - não enviando token');&#10;  }&#10;&#10;  return config;&#10;});&#10;&#10;api.interceptors.response.use(&#10;    (response) =&gt; {&#10;      if (DEBUG) {&#10;        console.log('✅ [API] Resposta recebida:', {&#10;          status: response.status,&#10;          url: response.config.url,&#10;          dataType: typeof response.data,&#10;          isArray: Array.isArray(response.data),&#10;          dataLength: Array.isArray(response.data) ? response.data.length : 'not array',&#10;          hasData: !!response.data,&#10;          dataKeys: response.data &amp;&amp; typeof response.data === 'object' ? Object.keys(response.data) : 'not object'&#10;        });&#10;        console.log(' [API] Dados completos recebidos:', response.data);&#10;      }&#10;      return response;&#10;    },&#10;    async (error) =&gt; {&#10;      if (DEBUG) {&#10;        console.error('❌ [API] Erro na resposta:', {&#10;          status: error.response?.status,&#10;          url: error.config?.url,&#10;          message: error.message,&#10;          data: error.response?.data&#10;        });&#10;      }&#10;&#10;      if (error.response?.status === 401) {&#10;        localStorage.removeItem('@EnglishForAllTime:token');&#10;&#10;        // Só redirecionar se não for rota pública&#10;        const isPublicRoute = error.config?.url?.includes('/auth/') ||&#10;            error.config?.url?.includes('/dictionary/');&#10;&#10;        if (!isPublicRoute) {&#10;          console.log(' [API] Redirecionando para login devido ao 401');&#10;          window.location.href = '/login';&#10;        }&#10;      }&#10;      return Promise.reject(error);&#10;    }&#10;);&#10;&#10;export default api;&#10;&#10;// Função principal do dicionário - CORRIGIDA para usar a rota correta&#10;export const getWordDetails = async (word) =&gt; {&#10;  try {&#10;    if (DEBUG) {&#10;      console.log(' [DICTIONARY] Iniciando busca para palavra:', word);&#10;    }&#10;&#10;    if (!word || !word.trim()) {&#10;      throw new Error('Palavra não pode estar vazia');&#10;    }&#10;&#10;    // CORRIGIDO: Usando a rota correta do DictionaryController (/api/dictionary/{word})&#10;    const response = await api.get(`/dictionary/${encodeURIComponent(word.trim())}`);&#10;&#10;    if (DEBUG) {&#10;      console.log('✅ [DICTIONARY] Resposta completa recebida:', {&#10;        status: response.status,&#10;        data: response.data,&#10;        dataType: typeof response.data,&#10;        hasData: !!response.data,&#10;        dataKeys: response.data ? Object.keys(response.data) : 'no data'&#10;      });&#10;    }&#10;&#10;    // Verificar se os dados foram recebidos corretamente&#10;    if (!response.data) {&#10;      throw new Error('Nenhum dado foi retornado pela API');&#10;    }&#10;&#10;    return response.data;&#10;  } catch (error) {&#10;    if (DEBUG) {&#10;      console.error('❌ [DICTIONARY] Erro na busca:', {&#10;        word,&#10;        status: error.response?.status,&#10;        message: error.message,&#10;        data: error.response?.data,&#10;        responseReceived: !!error.response&#10;      });&#10;    }&#10;&#10;    // Tratamento específico de erros baseado no backend Spring Boot&#10;    if (error.response?.status === 404) {&#10;      throw new Error(`Palavra &quot;${word}&quot; não encontrada no dicionário`);&#10;    } else if (error.response?.status === 400) {&#10;      throw new Error('Palavra inválida. Verifique a ortografia');&#10;    } else if (error.response?.status === 500) {&#10;      throw new Error('Erro interno do servidor. Tente novamente');&#10;    } else if (error.response?.status === 503) {&#10;      throw new Error('Serviço indisponível. Tente novamente mais tarde');&#10;    } else if (error.response?.status === 403) {&#10;      throw new Error('Acesso negado ao serviço de dicionário');&#10;    } else {&#10;      throw new Error(error.response?.data?.message || 'Erro ao buscar palavra no dicionário');&#10;    }&#10;  }&#10;};&#10;&#10;// Nova função para usar o endpoint de aninhamento do SemanticController&#10;export const getWordDetailsWithNesting = async (word) =&gt; {&#10;  try {&#10;    if (DEBUG) {&#10;      console.log(' [SEMANTIC] Iniciando busca com aninhamento para palavra:', word);&#10;    }&#10;&#10;    if (!word || !word.trim()) {&#10;      throw new Error('Palavra não pode estar vazia');&#10;    }&#10;&#10;    // Usando o novo endpoint de aninhamento&#10;    const response = await api.get(`/semantic/word/${encodeURIComponent(word.trim())}/nested`);&#10;&#10;    if (DEBUG) {&#10;      console.log('✅ [SEMANTIC] NestedWordDetailsDTO recebido:', response.data);&#10;    }&#10;&#10;    return response.data;&#10;  } catch (error) {&#10;    if (DEBUG) {&#10;      console.error('❌ [SEMANTIC] Erro na busca com aninhamento:', {&#10;        word,&#10;        status: error.response?.status,&#10;        message: error.message,&#10;        data: error.response?.data&#10;      });&#10;    }&#10;&#10;    if (error.response?.status === 404) {&#10;      throw new Error(`Palavra &quot;${word}&quot; não encontrada no dicionário`);&#10;    } else {&#10;      throw new Error(error.response?.data?.message || 'Erro ao buscar palavra com aninhamento');&#10;    }&#10;  }&#10;};&#10;&#10;// REMOVIDO: Funções de favoritos que não existem no backend&#10;// Estas funções foram comentadas até serem implementadas no backend:&#10;/*&#10;export const saveWordToFavorites = async (wordData) =&gt; {&#10;  // TODO: Implementar no backend primeiro&#10;};&#10;&#10;export const getSavedWords = async () =&gt; {&#10;  // TODO: Implementar no backend primeiro&#10;};&#10;*/&#10;&#10;// Manter compatibilidade com código existente&#10;export const searchWord = getWordDetails;&#10;&#10;// API do dicionário com funcionalidades disponíveis&#10;export const dictionaryApi = {&#10;  // Busca pública (sem autenticação) - rota corrigida&#10;  getWordDetails,&#10;  searchWord: getWordDetails,&#10;&#10;  // Nova funcionalidade de aninhamento&#10;  getWordDetailsWithNesting,&#10;&#10;  // FUTURAS funcionalidades (precisam ser implementadas no backend):&#10;  /*&#10;  saveWordToFavorites,&#10;  getSavedWords,&#10;  searchByCategory: async (category) =&gt; {&#10;    const response = await api.get(`/dictionary/category/${category}`);&#10;    return response.data;&#10;  },&#10;  getWordHistory: async () =&gt; {&#10;    const response = await api.get('/dictionary/history');&#10;    return response.data;&#10;  },&#10;  deleteFromFavorites: async (wordId) =&gt; {&#10;    const response = await api.delete(`/dictionary/saved/${wordId}`);&#10;    return response.data;&#10;  }&#10;  */&#10;};&#10;&#10;// Exportações para outras funcionalidades da aplicação (estas estão corretas)&#10;export const courseApi = {&#10;  getCourses: async () =&gt; {&#10;    const response = await api.get('/courses');&#10;    return response.data;&#10;  },&#10;&#10;  createCourse: async (courseData) =&gt; {&#10;    const response = await api.post('/courses', courseData);&#10;    return response.data;&#10;  },&#10;&#10;  updateCourse: async (id, courseData) =&gt; {&#10;    const response = await api.put(`/courses/${id}`, courseData);&#10;    return response.data;&#10;  },&#10;&#10;  deleteCourse: async (id) =&gt; {&#10;    const response = await api.delete(`/courses/${id}`);&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export const authApi = {&#10;  login: async (credentials) =&gt; {&#10;    const response = await api.post('/auth/login', credentials);&#10;    return response.data;&#10;  },&#10;&#10;  register: async (userData) =&gt; {&#10;    const response = await api.post('/auth/register', userData);&#10;    return response.data;&#10;  },&#10;&#10;  logout: async () =&gt; {&#10;    const response = await api.post('/auth/logout');&#10;    return response.data;&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import axios from 'axios';&#10;import { DEBUG } from '../util/debug';&#10;&#10;const api = axios.create({&#10;  baseURL: 'http://localhost:8080/api',&#10;  headers: {&#10;    'Content-Type': 'application/json',&#10;  }&#10;});&#10;&#10;api.interceptors.request.use((config) =&gt; {&#10;  if (DEBUG) {&#10;    console.log(' [API] Requisição saindo:', {&#10;      method: config.method?.toUpperCase(),&#10;      url: config.url,&#10;      baseURL: config.baseURL,&#10;      fullURL: `${config.baseURL}${config.url}`&#10;    });&#10;  }&#10;&#10;  // Rotas que NÃO precisam de autenticação (públicas)&#10;  const isPublicRoute = config.url?.includes('/auth/login') ||&#10;      config.url?.includes('/auth/register') ||&#10;      config.url?.includes('/dictionary/');  // Todas as rotas do dicionário são públicas&#10;&#10;  if (!isPublicRoute) {&#10;    const token = localStorage.getItem('@EnglishForAllTime:token');&#10;    if (token) {&#10;      config.headers.Authorization = `Bearer ${token}`;&#10;      if (DEBUG) console.log(' [API] Token adicionado à requisição');&#10;    } else {&#10;      if (DEBUG) console.log('⚠️ [API] Nenhum token encontrado no localStorage');&#10;    }&#10;  } else {&#10;    if (DEBUG) console.log(' [API] Rota pública - não enviando token');&#10;  }&#10;&#10;  return config;&#10;});&#10;&#10;api.interceptors.response.use(&#10;    (response) =&gt; {&#10;      if (DEBUG) {&#10;        console.log('✅ [API] Resposta recebida:', {&#10;          status: response.status,&#10;          url: response.config.url,&#10;          dataType: typeof response.data,&#10;          isArray: Array.isArray(response.data),&#10;          dataLength: Array.isArray(response.data) ? response.data.length : 'not array',&#10;          hasData: !!response.data,&#10;          dataKeys: response.data &amp;&amp; typeof response.data === 'object' ? Object.keys(response.data) : 'not object'&#10;        });&#10;        console.log(' [API] Dados completos recebidos:', response.data);&#10;      }&#10;      return response;&#10;    },&#10;    async (error) =&gt; {&#10;      if (DEBUG) {&#10;        console.error('❌ [API] Erro na resposta:', {&#10;          status: error.response?.status,&#10;          url: error.config?.url,&#10;          message: error.message,&#10;          data: error.response?.data&#10;        });&#10;      }&#10;&#10;      if (error.response?.status === 401) {&#10;        localStorage.removeItem('@EnglishForAllTime:token');&#10;&#10;        // Só redirecionar se não for rota pública&#10;        const isPublicRoute = error.config?.url?.includes('/auth/') ||&#10;            error.config?.url?.includes('/dictionary/');&#10;&#10;        if (!isPublicRoute) {&#10;          console.log(' [API] Redirecionando para login devido ao 401');&#10;          window.location.href = '/login';&#10;        }&#10;      }&#10;      return Promise.reject(error);&#10;    }&#10;);&#10;&#10;export default api;&#10;&#10;// Função principal do dicionário - CORRIGIDA para usar a rota correta&#10;export const getWordDetails = async (word) =&gt; {&#10;  try {&#10;    if (DEBUG) {&#10;      console.log(' [DICTIONARY] Iniciando busca para palavra:', word);&#10;    }&#10;&#10;    if (!word || !word.trim()) {&#10;      throw new Error('Palavra não pode estar vazia');&#10;    }&#10;&#10;    // CORRIGIDO: Usando a rota correta do DictionaryController (/api/dictionary/{word})&#10;    const response = await api.get(`/dictionary/${encodeURIComponent(word.trim())}`);&#10;&#10;    if (DEBUG) {&#10;      console.log('✅ [DICTIONARY] Resposta completa recebida:', {&#10;        status: response.status,&#10;        data: response.data,&#10;        dataType: typeof response.data,&#10;        hasData: !!response.data,&#10;        dataKeys: response.data ? Object.keys(response.data) : 'no data'&#10;      });&#10;    }&#10;&#10;    // Verificar se os dados foram recebidos corretamente&#10;    if (!response.data) {&#10;      throw new Error('Nenhum dado foi retornado pela API');&#10;    }&#10;&#10;    return response.data;&#10;  } catch (error) {&#10;    if (DEBUG) {&#10;      console.error('❌ [DICTIONARY] Erro na busca:', {&#10;        word,&#10;        status: error.response?.status,&#10;        message: error.message,&#10;        data: error.response?.data,&#10;        responseReceived: !!error.response&#10;      });&#10;    }&#10;&#10;    // Tratamento específico de erros baseado no backend Spring Boot&#10;    if (error.response?.status === 404) {&#10;      throw new Error(`Palavra &quot;${word}&quot; não encontrada no dicionário`);&#10;    } else if (error.response?.status === 400) {&#10;      throw new Error('Palavra inválida. Verifique a ortografia');&#10;    } else if (error.response?.status === 500) {&#10;      throw new Error('Erro interno do servidor. Tente novamente');&#10;    } else if (error.response?.status === 503) {&#10;      throw new Error('Serviço indisponível. Tente novamente mais tarde');&#10;    } else if (error.response?.status === 403) {&#10;      throw new Error('Acesso negado ao serviço de dicionário');&#10;    } else {&#10;      throw new Error(error.response?.data?.message || 'Erro ao buscar palavra no dicionário');&#10;    }&#10;  }&#10;};&#10;&#10;// Nova função para usar o endpoint de aninhamento do SemanticController&#10;export const getWordDetailsWithNesting = async (word) =&gt; {&#10;  try {&#10;    if (DEBUG) {&#10;      console.log(' [SEMANTIC] Iniciando busca com aninhamento para palavra:', word);&#10;    }&#10;&#10;    if (!word || !word.trim()) {&#10;      throw new Error('Palavra não pode estar vazia');&#10;    }&#10;&#10;    // Usando o novo endpoint de aninhamento&#10;    const response = await api.get(`/semantic/word/${encodeURIComponent(word.trim())}/nested`);&#10;&#10;    if (DEBUG) {&#10;      console.log('✅ [SEMANTIC] NestedWordDetailsDTO recebido:', response.data);&#10;    }&#10;&#10;    return response.data;&#10;  } catch (error) {&#10;    if (DEBUG) {&#10;      console.error('❌ [SEMANTIC] Erro na busca com aninhamento:', {&#10;        word,&#10;        status: error.response?.status,&#10;        message: error.message,&#10;        data: error.response?.data&#10;      });&#10;    }&#10;&#10;    if (error.response?.status === 404) {&#10;      throw new Error(`Palavra &quot;${word}&quot; não encontrada no dicionário`);&#10;    } else {&#10;      throw new Error(error.response?.data?.message || 'Erro ao buscar palavra com aninhamento');&#10;    }&#10;  }&#10;};&#10;&#10;// NOVA FUNCIONALIDADE: Rede Semântica de Palavras&#10;export const getSemanticNetwork = async (word) =&gt; {&#10;  try {&#10;    if (DEBUG) {&#10;      console.log(' [SEMANTIC NETWORK] Iniciando busca pela rede semântica da palavra:', word);&#10;    }&#10;&#10;    if (!word || !word.trim()) {&#10;      throw new Error('Palavra não pode estar vazia');&#10;    }&#10;&#10;    const response = await api.get(`/semantic/semantic-network/${encodeURIComponent(word.trim())}`);&#10;&#10;    if (DEBUG) {&#10;      console.log('✅ [SEMANTIC NETWORK] Rede semântica recebida:', response.data);&#10;    }&#10;&#10;    return response.data;&#10;  } catch (error) {&#10;    if (DEBUG) {&#10;      console.error('❌ [SEMANTIC NETWORK] Erro na busca pela rede semântica:', {&#10;        word,&#10;        status: error.response?.status,&#10;        message: error.message,&#10;        data: error.response?.data&#10;      });&#10;    }&#10;&#10;    if (error.response?.status === 404) {&#10;      throw new Error(`Rede semântica para a palavra &quot;${word}&quot; não encontrada`);&#10;    } else {&#10;      throw new Error(error.response?.data?.message || 'Erro ao buscar rede semântica');&#10;    }&#10;  }&#10;};&#10;&#10;// REMOVIDO: Funções de favoritos que não existem no backend&#10;// Estas funções foram comentadas até serem implementadas no backend:&#10;/*&#10;export const saveWordToFavorites = async (wordData) =&gt; {&#10;  // TODO: Implementar no backend primeiro&#10;};&#10;&#10;export const getSavedWords = async () =&gt; {&#10;  // TODO: Implementar no backend primeiro&#10;};&#10;*/&#10;&#10;// Manter compatibilidade com código existente&#10;export const searchWord = getWordDetails;&#10;&#10;// API do dicionário com funcionalidades disponíveis&#10;export const dictionaryApi = {&#10;  // Busca pública (sem autenticação) - rota corrigida&#10;  getWordDetails,&#10;  searchWord: getWordDetails,&#10;&#10;  // Nova funcionalidade de aninhamento&#10;  getWordDetailsWithNesting,&#10;&#10;  // FUTURAS funcionalidades (precisam ser implementadas no backend):&#10;  /*&#10;  saveWordToFavorites,&#10;  getSavedWords,&#10;  searchByCategory: async (category) =&gt; {&#10;    const response = await api.get(`/dictionary/category/${category}`);&#10;    return response.data;&#10;  },&#10;  getWordHistory: async () =&gt; {&#10;    const response = await api.get('/dictionary/history');&#10;    return response.data;&#10;  },&#10;  deleteFromFavorites: async (wordId) =&gt; {&#10;    const response = await api.delete(`/dictionary/saved/${wordId}`);&#10;    return response.data;&#10;  }&#10;  */&#10;};&#10;&#10;// Exportações para outras funcionalidades da aplicação (estas estão corretas)&#10;export const courseApi = {&#10;  getCourses: async () =&gt; {&#10;    const response = await api.get('/courses');&#10;    return response.data;&#10;  },&#10;&#10;  createCourse: async (courseData) =&gt; {&#10;    const response = await api.post('/courses', courseData);&#10;    return response.data;&#10;  },&#10;&#10;  updateCourse: async (id, courseData) =&gt; {&#10;    const response = await api.put(`/courses/${id}`, courseData);&#10;    return response.data;&#10;  },&#10;&#10;  deleteCourse: async (id) =&gt; {&#10;    const response = await api.delete(`/courses/${id}`);&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export const authApi = {&#10;  login: async (credentials) =&gt; {&#10;    const response = await api.post('/auth/login', credentials);&#10;    return response.data;&#10;  },&#10;&#10;  register: async (userData) =&gt; {&#10;    const response = await api.post('/auth/register', userData);&#10;    return response.data;&#10;  },&#10;&#10;  logout: async () =&gt; {&#10;    const response = await api.post('/auth/logout');&#10;    return response.data;&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>